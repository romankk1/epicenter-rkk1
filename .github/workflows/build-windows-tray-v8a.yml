name: Build Windows Tray v8a

on:
  workflow_dispatch:

jobs:
  build:
    runs-on: windows-latest
    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Clone upstream epicenter (latest main)
        run: |
          git clone https://github.com/epicenter-md/epicenter.git epicenter-up
          cd epicenter-up
          git fetch --all --prune
          git checkout origin/main -B tray-build

      - name: Add tray feature remote & fetch
        run: |
          cd epicenter-up
          git remote add tray https://github.com/vishesh-sachan/epicenter.git
          git fetch tray feature/minimize-to-tray

      - name: Merge tray feature (prefer tray)
        run: |
          cd epicenter-up
          git config user.name "tray-bot"
          git config user.email "tray-bot@users.noreply.github.com"
          git merge --no-edit -X theirs tray/feature/minimize-to-tray || true
          git add -A || true
          git commit -m "Temp merge: upstream main + tray feature for build" || true

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Setup Rust (MSVC)
        uses: dtolnay/rust-toolchain@stable

      - name: Install WiX Toolset
        shell: pwsh
        run: |
          choco install wixtoolset --yes --no-progress || $true
          $candle = (Get-Command candle.exe -ErrorAction SilentlyContinue)?.Source
          if (-not $candle) {
            $guess = Get-ChildItem "C:\Program Files (x86)" -Filter "WiX Toolset v3.*" -Directory -ErrorAction SilentlyContinue |
                     ForEach-Object { Join-Path $_.FullName "bin\candle.exe" } |
                     Where-Object { Test-Path $_ } |
                     Select-Object -First 1
            if ($guess) { $env:Path = "$env:Path;$(Split-Path $guess)" }
          }
          Write-Host "WiX ready"

      - name: Install NSIS
        shell: pwsh
        run: |
          choco install nsis --yes --no-progress
          $p1 = 'C:\Program Files (x86)\NSIS\makensis.exe'
          $p2 = 'C:\Program Files\NSIS\makensis.exe'
          if (Test-Path $p1) { $env:Path = "$env:Path;$(Split-Path $p1)" }
          elseif (Test-Path $p2) { $env:Path = "$env:Path;$(Split-Path $p2)" }
          Write-Host "NSIS ready"

      - name: Cache Bun
        uses: actions/cache@v4
        with:
          path: ~/.bun/install/cache
          key: ${{ runner.os }}-bun-${{ hashFiles('epicenter-up/**/bun.lock') }}
          restore-keys: ${{ runner.os }}-bun-

      - name: Install deps
        working-directory: epicenter-up
        run: bun install

      - name: Pre-patch (no-regex JS file: spans, ffmpeg shims, imports, TIMESLICE_MS)
        working-directory: epicenter-up/apps/whispering
        run: |
          cat > prepatch.js << 'JS'
          const fs = require('fs');
          const path = require('path');

          function fixSpan(file) {
            if (!fs.existsSync(file)) return;
            let s = fs.readFileSync(file, 'utf8');
            // Sostituisci <span .../> con <span ...></span> senza regex complicate
            s = s.replace(/<span([^>]*)\/>/g, (_m, g1) => `<span${g1}></span>`);
            fs.writeFileSync(file, s);
            console.log('Fixed <span/> in', file);
          }

          function ensureShim(target) {
            if (fs.existsSync(target)) return;
            fs.mkdirSync(path.dirname(target), { recursive: true });
            fs.writeFileSync(
              target,
              [
                "export type FfmpegCheck = { available: boolean; version?: string; error?: string };",
                "export async function checkFfmpeg(): Promise<FfmpegCheck> {",
                "  return { available: true, version: 'CI' };",
                "}",
                "export default checkFfmpeg;",
                ""
              ].join("\n")
            );
            console.log('Created shim', target);
          }

          function dedupeResultImports(file) {
            if (!fs.existsSync(file)) return;
            const lines = fs.readFileSync(file, 'utf8').split(/\r?\n/);
            let kept = false;
            const out = [];
            for (const line of lines) {
              const trimmed = line.trim();
              const isResultImport = /^import\s*\{[^}]*\}\s*from\s*['"]wellcrafted\/result['"];?$/.test(trimmed);
              if (isResultImport) {
                if (!kept) {
                  out.push("import { Err, Ok } from 'wellcrafted/result';");
                  kept = true;
                }
                continue;
              }
              out.push(line);
            }
            fs.writeFileSync(file, out.join('\n'));
            console.log('Deduped wellcrafted/result imports in', file);
          }

          function dedupeNanoidImport(file) {
            if (!fs.existsSync(file)) return;
            let lines = fs.readFileSync(file, 'utf8').split(/\r?\n/);
            let seen = false;
            lines = lines.filter((l) => {
              const trimmed = l.trim();
              const isNano = /^import\s*\{\s*nanoid\s*\}\s*from\s*['"]nanoid(\/non-secure)?['"];?$/.test(trimmed);
              if (isNano) {
                if (seen) return false;
                seen = true;
                return true;
              }
              return true;
            }).map((l) => l.replace(/from\s*['"]nanoid['"]/, "from 'nanoid/non-secure'"));
            fs.writeFileSync(file, lines.join('\n'));
            console.log('Deduped nanoid import in', file);
          }

          function fixTimeslice(file) {
            if (!fs.existsSync(file)) return;
            let s = fs.readFileSync(file, 'utf8');
            const hasImport = s.includes("from '$lib/constants/audio'") && s.includes('TIMESLICE_MS');
            let changed = false;

            // Se non importa ancora dai constants, aggiungi l'import in testa
            if (!s.includes("from '$lib/constants/audio'")) {
              s = "import { TIMESLICE_MS } from '$lib/constants/audio';\n" + s;
              changed = true;
            }
            // Rimuovi qualsiasi dichiarazione locale di const TIMESLICE_MS
            const out = [];
            for (const line of s.split(/\r?\n/)) {
              const t = line.trim();
              if (t.startsWith('const TIMESLICE_MS') || t.startsWith('export const TIMESLICE_MS')) {
                changed = true;
                continue;
              }
              out.push(line);
            }
            if (changed) {
              fs.writeFileSync(file, out.join('\n'));
              console.log('Normalized TIMESLICE_MS in', file);
            } else {
              console.log('No TIMESLICE_MS change needed in', file);
            }
          }

          // 1) spans
          fixSpan('src/routes/(config)/settings/transcription/+page.svelte');
          // 2) ffmpeg shims (entrambi i percorsi)
          ensureShim('src/routes/(config)/+layout/check-ffmpeg.ts');
          ensureShim('src/routes/+layout/check-ffmpeg.ts');
          // 3) imports in commands.ts
          dedupeResultImports('src/lib/query/commands.ts');
          dedupeNanoidImport('src/lib/query/commands.ts');
          // 4) TIMESLICE_MS in navigator.ts
          fixTimeslice('src/lib/services/recorder/navigator.ts');
          JS

          node prepatch.js

      - name: Install Tauri CLI
        run: |
          bun add -g @tauri-apps/cli@latest
          bun --version
          tauri -V || true

      - name: Build (Tauri)
        working-directory: epicenter-up/apps/whispering
        env:
          CI: "true"
        run: |
          echo "PATH=$PATH"
          which bun || true
          which tauri || true
          bun tauri build || bunx --bun tauri build

      - name: Upload installers
        uses: actions/upload-artifact@v4
        with:
          name: whispering-windows-with-tray
          path: |
            epicenter-up/apps/whispering/src-tauri/target/release/bundle/**/*.msi
            epicenter-up/apps/whispering/src-tauri/target/release/bundle/**/*.exe
            epicenter-up/apps/whispering/src-tauri/target/release/bundle/**/*.zip
